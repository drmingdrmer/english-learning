## Raft 读索引的标准实现过程

Raft 中处理读索引的标准过程如下：

- **步骤 1**：领导者检查当前任期的日志是否已经提交。如果没有提交，它会放弃读取操作，返回并等待当前任期的日志被提交。
- **步骤 2**：领导者将当前的 CommitIndex 作为读索引。
- **步骤 3**：领导者向法定人数发送心跳以确认自己是唯一的领导者。
- **步骤 4**：在执行状态机的读操作之前，它等待 AppliedIndex 达到或超过读索引。

通过以上步骤，这个过程确保：
**在读操作发生的时间点之前已经读取的任何数据也可以在这个读操作中被读取**，从而保证了线性可读性。

让我们来看一下如何确保线性可读性：

## 线性可读性的简单证明

当当前节点（领导者）收到一个读请求 `read_1`，假设当前的墙钟时间为 `time_1`，领导者的任期为 `term_1`；

假设还有另一个读请求 `read_0` 发生在之前的时间，即 `time_0`：`time_0 < time_1`，
那么读取过程必须确保 `read_1` 能够读取到 `read_0` 读取的所有状态，以保证线性可读性。

假设 `read_0` 读取的状态机包括从 `(0, 0)` 到 `(term_0, index_0)` 的一系列日志状态，其中 `(term_0, index_0)` 是 `read_0` 所见到的最后一个日志。
在这种情况下，对于 `term_0`，有三种可能性：

- **case-gt**：`term_0 > term_1`：为了避免这种无法处理的情况，领导者在时间 `t` 向法定人数发送心跳请求，以确认在时间范围 `(0, t)` 内没有更高的任期；显然，`t` 是在收到读请求 `read_1` 之后，即 `t >= time_1`，从而确保在读请求 `read_1` 收到的时刻 `time_1`，没有其他读者读取到更高任期的日志（**步骤 3**）。
- **case-eq**：`term_0 == term_1`：在这种情况下，读操作 `read_0` 必须由当前节点执行；我们还知道根据 Raft 协议，只有已提交的日志才能被读取，所以 `read_0` 读取的数据必须在当前的 CommitIndex 之前，即 `index_0 <= CommitIndex`；为了确保在这种情况下的线性可读性，也就是确保 `read_1` 看到 `read_0` 看到的所有状态，需要在 `read_1` 的时刻，状态机至少包含到 CommitIndex 的日志。
- **case-lt**：`term_0 < term_1`：在这种情况下，由于 Raft 保证当前领导者在建立时包含了所有已提交的日志，所以 `index_0 < NoopIndex`，其中 `NoopIndex` 是领导者建立时写入的空操作日志的索引；为了确保在这种情况下的线性可读性，需要在 `read_1` 的时刻，状态机至少包含到 `NoopIndex` 的日志。

根据以上分析，排除了 **case-gt**，当满足 **case-lt** 时，即在 `NoopIndex` 被提交之后（**步骤 1**），只需要考虑 **case-eq**（**步骤 2**），也就是在读取之前等待状态机应用至少到 CommitIndex（**步骤 4**），这确保了 `read_1` 一定能看到 `read_0` 看到的状态，即线性可读性。